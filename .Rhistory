india@data$test <- sample(65000:200000000, size = nrow(india@data),
replace = TRUE)
# breaks the shapefile down to points for compatibility with ggplot2
indiaF <- fortify(india, region = "ID_1")
indiaF <- merge(indiaF, india, by.x = "id", by.y = "ID_1")
# plots the polygon and fills them with the value of 'test'
ggplot() +
geom_polygon(data = indiaF, aes(x = long, y = lat, group = group,
fill = test)) +
coord_equal()
```
install.packages("rgdal")
require("rgdal")  # needed to load shapefiles
# obtain India administrative shapefiles and unzip
download.file("http://biogeo.ucdavis.edu/data/diva/adm/IND_adm.zip",
destfile = "IND_adm.zip")
unzip("IND_adm.zip", overwrite = TRUE)
# load shapefiles
india <- readOGR(dsn = "shapes/", "IND_adm1")
# check they've loaded correctly with a plot
plot(india)
# all fine. Let's plot an example variable using ggplot2
require("ggplot2")
require("rgeos")  # for fortify() with SpatialPolygonsDataFrame types
india@data$test <- sample(65000:200000000, size = nrow(india@data),
replace = TRUE)
# breaks the shapefile down to points for compatibility with ggplot2
indiaF <- fortify(india, region = "ID_1")
indiaF <- merge(indiaF, india, by.x = "id", by.y = "ID_1")
# plots the polygon and fills them with the value of 'test'
ggplot() +
geom_polygon(data = indiaF, aes(x = long, y = lat, group = group,
fill = test)) +
coord_equal()
```
```{r, echo=FALSE}
install.packages("rgdal")
install.packages("rgeos")
require("rgdal")  # needed to load shapefiles
# obtain India administrative shapefiles and unzip
download.file("http://biogeo.ucdavis.edu/data/diva/adm/IND_adm.zip",
destfile = "IND_adm.zip")
unzip("IND_adm.zip", overwrite = TRUE)
# load shapefiles
india <- readOGR(dsn = "shapes/", "IND_adm1")
# check they've loaded correctly with a plot
plot(india)
# all fine. Let's plot an example variable using ggplot2
require("ggplot2")
require("rgeos")  # for fortify() with SpatialPolygonsDataFrame types
india@data$test <- sample(65000:200000000, size = nrow(india@data),
replace = TRUE)
# breaks the shapefile down to points for compatibility with ggplot2
indiaF <- fortify(india, region = "ID_1")
indiaF <- merge(indiaF, india, by.x = "id", by.y = "ID_1")
# plots the polygon and fills them with the value of 'test'
ggplot() +
geom_polygon(data = indiaF, aes(x = long, y = lat, group = group,
fill = test)) +
coord_equal()
```
install.packages("rgeos")
require("rgdal")  # needed to load shapefiles
# obtain India administrative shapefiles and unzip
download.file("http://biogeo.ucdavis.edu/data/diva/adm/IND_adm.zip",
destfile = "IND_adm.zip")
unzip("IND_adm.zip", overwrite = TRUE)
# load shapefiles
india <- readOGR(dsn = "shapes/", "IND_adm1")
# check they've loaded correctly with a plot
plot(india)
# all fine. Let's plot an example variable using ggplot2
require("ggplot2")
require("rgeos")  # for fortify() with SpatialPolygonsDataFrame types
india@data$test <- sample(65000:200000000, size = nrow(india@data),
replace = TRUE)
# breaks the shapefile down to points for compatibility with ggplot2
indiaF <- fortify(india, region = "ID_1")
indiaF <- merge(indiaF, india, by.x = "id", by.y = "ID_1")
# plots the polygon and fills them with the value of 'test'
ggplot() +
geom_polygon(data = indiaF, aes(x = long, y = lat, group = group,
fill = test)) +
coord_equal()
p = ggplot(data = df_state, aes(x=state_2, y=relativepayment))
p = p + geom_bar(stat = "identity") + coord_flip() + labs(title = "Figure 4: Log(payment pr. 10,000 inhabitants",
x = "State",
y = "Log(Total payment)")
p = p + scale_y_log10()
plot(p)
View(df_state)
---
title: "Assignment 2 - group 16"
author: "Bjarke Dahl Mogensen, Mikkel Mertz og Benjamin Wedel Mathiasen"
date: "9. nov. 2015"
output: html_document
---
```{r, echo = FALSE, cache=FALSE}
library ("plyr")
library ("dplyr")
library ("rvest")
library ("readr")
library ("knitr")
library ("stringr")
library ("xml2")
library ("ggplot2")
library("mapproj")
```
```{r, echo=FALSE, cache=FALSE}
link_ipaidabribe = paste("http://www.ipaidabribe.com/reports/paid?page=", 0:99, 0, sep = "")
scrape_ipaidabribe = function (link_ipaidabribe) {
my.link = read_html(link_ipaidabribe, encoding= "UTF-8")
location = my.link %>%
html_nodes(".location " ) %>%
html_text()
date = my.link %>%
html_nodes(".date " ) %>%
html_text()
transactiondetail = my.link %>%
html_nodes(".transaction a" ) %>%
html_text()
depname = my.link %>%
html_nodes(".name a" ) %>%
html_text()
title = my.link %>%
html_nodes(".heading-3 a" ) %>%
html_text()
views = my.link %>%
html_nodes(".overview .views" ) %>%
html_text()
payment = my.link %>%
html_nodes(".paid-amount span" ) %>%
html_text()
refnumber = my.link %>%
html_nodes(".unique-reference" ) %>%
html_text()
return (cbind(title, payment, depname, transactiondetail, views, location, date, refnumber))
}
my.ipaidabribe.data = list()
for (i in link_ipaidabribe){
print(paste("processing", i, sep = " "))
my.ipaidabribe.data[[i]] = scrape_ipaidabribe(i)
Sys.sleep(0.25)
cat(" done!\n")
}
df=ldply(my.ipaidabribe.data, data.frame)
```
```{r, echo=FALSE, cache=FALSE}
df.backup = df
df$payment = gsub(",","",df$payment)
df$payment = as.numeric(word(df$payment, +3)) # generating variable with only the price
```
This analysis seeks to illuminate the structure of bribes in India. We do this using data from the website ipaidabribe.com. This is a website where peoble can write if they bribed someone. Peoble are able to inform of various aspects of their bribe such as: how much they paid, where they paid it and to whom. Since the data relies on peoble to report their bribes themselfs we are not observing every bribe, but as long as there isn't a bias in the data left out this is not going to affect our main conclusions. You might think of it like this: if the older generation does not report any bribes and this subsection of the pupulation bribes peoble for different reasons this would bias our results. However we do not think this is a problem, so we keep to the information availible to us and even if it is only decribing a subsection of the population it is still relevant.
When considering the structure of bribes one interesting part to analyze could be the size of the bribes and how much they vary. The mean, median, maximum and minimum of the bribe payments are shown in table 1. as we see there is a very big gab between the highest and lowest payment, but its also worth to notise the very big gab between the mean and median.
Table 1 - Summary statistics
```{r, echo=FALSE, cache=FALSE}
summary(df$payment)
```
Because of the large big variation in the size of the amounts being payed We consider the distribution of payments in figure 1. In figure 1 the density is shown to the log of payments to center the a bit. Even within this transformation the distribuion seems to have a very long tail to the right indicating that the majority of the payments are in the smaller area, but there is a few very large bribes.
```{r, echo=FALSE, cache=FALSE}
df$India = "India"
df$logpayments = log(df$payment)
boxplot(logpayments~India, data = df, main = "Distribution of payments",
ylab = "Log(Payment)")
# Jeg kan ikke lige finde ud af om det er bedre med et Boxplot, men ellers kan vi slette det ;D
p = ggplot(data = df, aes(x = payment))
p = p + geom_density() + labs(title = "Figure 1: Distribution of bribe payments", x = "Log(Payment)", y = "Density")
p = p + scale_x_log10()
p = p + theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black"))
plot(p)
```
As shown above the size of bribes vary a lot, but who primarily receives the bribe and for what? This is what we are going to consider in the next section. In this section we only consider the number of bribes and leaves the size of the bribe be for a moment. Figure 2 shows the number of bribes reported to each department. Amon the departments reported are the police, transportation, municipalities etc.
```{r, echo=FALSE}
df.dep = df %>%
filter(!is.na(depname)) %>% #Removing payments with missing department
group_by(depname)
p = ggplot(data = df.dep, aes(x = depname))
p = p + geom_histogram() + coord_flip() + labs(title = "Figure 2: How many bribes do the departments get",
x = "Department",
y = "Number of bribes")
p = p + theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black"))
plot(p)
```
As figure 2 shows the majority of the bribes goes to municipal service, while "Food, Civil Suppliers and Consumer Affairs" and the police gets second and third most bribes. Since the majority of the bribes goes to municipality serveces it is interesting to see what kind of services the municipalities gets bribed for. This is shown in figure 3.
```{r, echo=FALSE}
df.transaction = subset(df, depname=="Municipal Services") %>%
filter(!is.na(transactiondetail)) %>% #Removing payments with missing transaction detail
group_by(transactiondetail)
p = ggplot(data = df.transaction, aes(x = transactiondetail))
p = p + geom_histogram() + coord_flip() + labs(title = "Figure 3: What do the municipalities get bribed for",
x = "Action",
y = "Number of bribes")
p = p + theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.background = element_blank(),
axis.line = element_line(colour = "black"))
plot(p)
```
As indicated by figure 3 the vast majority of the bribes goes to the category "Birth Certificates" and only a very small fraction of the bribes goes to the other categories with the largest being registration of land.
So far we have only considered the overall bribes and size of bribes in entire India. In this section however we dive a little bit more into the different states of India. We want to consider the average sum of payments per 10.000 inhabitants in the different states. This is illustrated in figure 4 where we plot the logarithmic transformation of the sum of payements per 10.000 individual in each state. As figure 4 shows there is a great different in the average payment.
```{r, echo = FALSE}
#Scraping populationdata for India from wikipedia:
India_pop =  read_html("https://en.wikipedia.org/wiki/Demographics_of_India") %>%
html_nodes(xpath= '//*[@id="mw-content-text"]/table[4]') %>%
html_table( )
df_India_pop=ldply(India_pop, data.frame)
df_India_pop$state_2 = df_India_pop$State...Union.Territory
#creating a state-variable in df
df$State = df$location %>%
str_replace_all(pattern = "[A-Z][a-z]*\r\n" , replacement= " ") %>%
str_trim()
df$state_1 = gsub(",", "", df$State)
#Creating a new dataframe with total payment per state
df_state = df %>%
filter(!is.na(state_1) & !(df$state_1 =="")) %>%
group_by(state_1) %>%
summarise(total.payments = sum(payment, na.rm = TRUE))
df_state$state_2 = gsub("^\\s+", "", df_state$state_1)
#By Comparing the data from wiki and the data from ipaidabribe we see that there are some of the state-names that differ. We make sure that at least the states with the biggest total payment are semilar in the two dataframes. We find out that there is a problem with New Delhi and fix that:
df_state[29,"state_2"]="Delhi"
#Joining the data from wiki with df_state
df_state = inner_join(df_India_pop, df_state, by="state_2")
df_state$pop=gsub(",", "",df_state$Population.24.)
df_state$pop1 = gsub("^\\s+", "", df_state$pop)
#Construction a new variable 'relativepayment'
as.numeric(df_state$pop1)
as.numeric(df_state$total.payments)
df_state$relativepayment = as.numeric(df_state$total.payments) / as.numeric(df_state$pop1) * 10000
arrange(df_state, -relativepayment)
#Plotting the data to se the states with the highest relative bribe payments
p = ggplot(data = df_state, aes(x=state_2, y=relativepayment))
p = p + geom_bar(stat = "identity") + coord_flip() + labs(title = "Figure 4: Log(payment pr. 10,000 inhabitants",
x = "State",
y = "Log(Total payment)")
p = p + scale_y_log10()
plot(p)
```
Some of the states as Manipur, Haryana and Arunachal Pradesh has a very low average, the logarithmic transformation is actually negative - indicating a payment between 0 and 1 per inhabitant. In the opposite side of the table Madhya Pradesh has by far the largest sum of payments per inhabitant with an average sum of 1.300.000 (This seems crazy high ?) per inhabitant.
p = ggplot(data = df_state, aes(x=state_2, y=relativepayment))
p = p + geom_bar(stat = "identity") + coord_flip() + labs(title = "Figure 4: Log(payment pr. 10,000 inhabitants",
x = "State",
y = "Log(Total payment)")
p = p + scale_y_log10()
plot(p)
install.packages("readr")
install.packages("devtools")
install.packages("ggplot2")
install.packages("ggplot2")
install.packages("ggplot2")
install.packages("dply")
install.packages("dplyr")
install.packages("stringr")
install.packages("stringr")
## ---- message = FALSE, warning = FALSE-----------------------------------
library("readr")
df = read_csv("https://raw.githubusercontent.com/sebastianbarfort/sds/master/data/politiken.csv",
col_types = list(created_time = col_character()))
df$created_time = parse_datetime(df$created_time)
## ---- message = FALSE, warning = FALSE-----------------------------------
library("ggplot2")
p = ggplot(data = df, aes(x = likes_count)) # data & aesthetics
p + geom_histogram() # add geom
## ---- message = FALSE, warning = FALSE-----------------------------------
p = ggplot(data = df, aes(x = likes_count)) # data & aesthetics
p = p + geom_histogram() # add geom
p + scale_x_log10() # add log scale
## ---- message = FALSE, warning = FALSE-----------------------------------
p = ggplot(data = df, aes(x = likes_count)) # data & aesthetics
p = p + geom_density() # add geom
p + scale_x_log10() # add log scale
## ---- message = FALSE, warning = FALSE-----------------------------------
p = ggplot(data = df, aes(x = likes_count)) # data & aesthetics
p = p + geom_area(stat = "bin") # add geom
p + scale_x_log10() # add log scale
## ---- message = FALSE, warning = FALSE-----------------------------------
p = ggplot(data = df, aes(x = likes_count)) # data & aesthetics
p + geom_histogram(aes(y=..density..), colour="black", fill="white") +
geom_density(alpha=.2, fill="#FF6666") + scale_x_log10()
## ---- message = FALSE, warning = FALSE-----------------------------------
p = ggplot(data = df, aes(x = likes_count, y = comments_count))
p + geom_point() + scale_x_log10() + scale_y_log10() # add log scales
## ---- message = FALSE, warning = FALSE-----------------------------------
p + geom_point() + geom_smooth(na.rm = TRUE,
data = df[df$likes_count>0 & df$comments_count>0,]) +
geom_smooth(na.rm = TRUE,
data = df[df$likes_count>0 & df$comments_count>0,],
method = "lm", colour = "red") +
scale_x_log10() + scale_y_log10() # add log scales
## ---- message = FALSE, warning = FALSE-----------------------------------
p = ggplot(df, aes(x = as.Date(created_time), y = likes_count))
p + geom_line()
## ------------------------------------------------------------------------
head(df$link, 3)
## ---- message = FALSE, warning = FALSE-----------------------------------
library("stringr")
df$section = str_extract(df$link, ".dk/[a-z]*")
df$section = gsub(".dk/", "", df$section)
head(df$section, 5)
## ---- message = FALSE, warning = FALSE-----------------------------------
library("dplyr")
df.section = df %>%
filter(!is.na(section)) %>%
filter(section != "") %>%
group_by(section) %>%
summarise(
likes.pr.post = mean(likes_count, na.rm = TRUE)
) %>%
arrange(-likes.pr.post)
## ---- message = FALSE, warning = FALSE-----------------------------------
p = ggplot(df.section, aes(x = reorder(section, likes.pr.post),
y = likes.pr.post))
p + geom_bar(stat = "identity") + coord_flip()
## ---- message = FALSE, warning = FALSE-----------------------------------
library("lubridate")
df$weekday = wday(df$created_time, label = TRUE)
## ---- message = FALSE, warning = FALSE-----------------------------------
p = ggplot(df, aes(x = likes_count, colour = weekday))
p = p + geom_density() + scale_x_log10()
## ---- message = FALSE, warning = FALSE, echo = FALSE---------------------
p = ggplot(df, aes(x = likes_count, colour = weekday))
p + geom_density() + scale_x_log10()
## ---- message = FALSE, warning = FALSE-----------------------------------
p = ggplot(df, aes(x = likes_count, y = comments_count))
p = p + geom_point() + scale_x_log10() + scale_y_log10() +
geom_smooth(na.rm = TRUE,
data = df[df$likes_count>0 & df$comments_count>0,]) +
facet_wrap(~ weekday, scales = "free")
## ---- message = FALSE, warning = FALSE, echo = FALSE---------------------
p = ggplot(df, aes(x = likes_count, y = comments_count))
p + geom_point() + scale_x_log10() + scale_y_log10() +
geom_smooth(na.rm = TRUE,
data = df[df$likes_count>0 & df$comments_count>0,]) +
facet_wrap(~ weekday, scales = "free")
## ---- message = FALSE, warning = FALSE-----------------------------------
df.subset = df %>%
filter(section %in% c("indland", "udland"))
## ---- message = FALSE, warning = FALSE, results="hide"-------------------
p = ggplot(df.subset, aes(x = likes_count, y = comments_count))
p = p + geom_point() + scale_x_log10() + scale_y_log10() +
geom_smooth(na.rm = TRUE,
data = df.subset[df.subset$likes_count>0 &
df.subset$comments_count>0,]) +
facet_grid(section~ weekday, scales = "free")
## ---- message = FALSE, warning = FALSE, echo = FALSE---------------------
p = ggplot(df.subset, aes(x = likes_count, y = comments_count))
p + geom_point() + scale_x_log10() + scale_y_log10() +
geom_smooth(na.rm = TRUE,
data = df.subset[df.subset$likes_count>0 & df.subset$comments_count>0,]) +
facet_grid(section~ weekday, scales = "free")
## ---- message = FALSE, warning = FALSE, echo = FALSE---------------------
p = ggplot(df.subset, aes(x = likes_count, y = comments_count,
size = shares_count, colour = weekday, shape = section))
p + geom_point() + scale_x_log10() + scale_y_log10()
## ---- message = FALSE, warning = FALSE-----------------------------------
tab = data.frame(table(df$section, df$weekday))
names(tab) = c("section", "weekday", "count")
## ---- message = FALSE, warning = FALSE-----------------------------------
p = ggplot(tab, aes(x = section, y = weekday))
p = p + geom_tile(aes(fill = count))
## ---- message = FALSE, warning = FALSE, echo = FALSE---------------------
p = ggplot(tab, aes(x = section, y = weekday))
p = p + geom_tile(aes(fill = count)) +
theme(axis.text.x = element_text(angle=90))
p
## ---- message = FALSE, warning = FALSE, echo = FALSE---------------------
p = ggplot(df, aes(x = section))
p + geom_histogram()
## ---- message = FALSE, warning = FALSE, echo = FALSE, echo = FALSE-------
p = ggplot(df, aes(x = likes_count, y = comments_count))
p + geom_point(alpha = .35) + scale_x_log10() + scale_y_log10()
## ---- message = FALSE, warning = FALSE, echo = FALSE, echo = FALSE-------
p = ggplot(df[df$likes_count>0 & df$comments_count>0,],
aes(x = likes_count, y = comments_count))
p + geom_hex() + scale_x_log10() + scale_y_log10() +
scale_fill_continuous(trans="log10")
## ---- message = FALSE, warning = FALSE, echo = FALSE---------------------
p = ggplot(df, aes(x = as.Date(created_time), y = likes_count))
p + geom_line() + labs(title = "Number of likes over time",
y = "number of likes", x = "time")
## ---- message = FALSE, warning = FALSE, echo = FALSE---------------------
p = ggplot(df, aes(x = as.Date(created_time), y = likes_count))
p + geom_line() + labs(title = "Number of likes over time",
y = "number of likes", x = "time") + theme_minimal()
## ---- message = FALSE, warning = FALSE, echo = FALSE---------------------
p = ggplot(df, aes(x = likes_count, y = comments_count))
p + geom_point(alpha = .25) + scale_x_log10() + scale_y_log10() +
geom_smooth(na.rm = TRUE,
data = df[df$likes_count>0 &
df$comments_count>0,],
colour = "green") +
geom_rug() + theme_minimal() +
labs(x = "likes (log scale)", y = "comments (log scale)",
title = "Relationship between likes and comments on Politiken's Facebook page")
## ---- message = FALSE, warning = FALSE, echo = FALSE---------------------
p = ggplot(df.subset, aes(x = likes_count,
y = comments_count, colour = section))
p + geom_point(alpha = .25) + scale_x_log10() + scale_y_log10() +
geom_smooth(na.rm = TRUE,
data = df.subset[df.subset$likes_count>0 &
df.subset$comments_count>0,],
method = "lm") +
geom_rug() + theme_minimal() +
labs(x = "likes (log scale)", y = "comments (log scale)",
title = "Relationship between likes and comments on Politiken's Facebook page")
install.packages("knitr")
## ---- message = FALSE, warning = FALSE, eval = FALSE---------------------
## # install.packages("knitr")
## library("knitr")
## purl("https://raw.githubusercontent.com/sebastianbarfort/sds/gh-pages/_slides/lecture3.Rmd")
## ---- message = FALSE, warning = FALSE-----------------------------------
library("readr")
df = read_csv("https://raw.githubusercontent.com/sebastianbarfort/sds/master/data/marijuana-street-price-clean.csv")
## ---- message = FALSE, warning = FALSE-----------------------------------
library("lubridate")
library("dplyr")
df$year = year(df$date)
df = df %>%
group_by(State, year) %>%
summarise(
m.price = mean(HighQ, na.rm = TRUE)
) %>%
mutate(
region = tolower(State)
)
## ---- message = FALSE, warning = FALSE-----------------------------------
library("maps")
library("ggplot2")
us.states = map_data("state")
head(us.states)
## ---- message = FALSE, warning = FALSE-----------------------------------
df.merge = left_join(df, us.states)
## ---- message = FALSE, warning = FALSE-----------------------------------
p = ggplot(df.merge, aes(x = long, y = lat, group = group)) +
geom_polygon(aes(fill = m.price)) +
facet_wrap( ~ year, ncol = 1) +
expand_limits() +
theme_minimal()
## ---- message = FALSE, warning = FALSE, echo = FALSE, fig.width = 5, fig.height = 6----
ggplot(df.merge, aes(x = long, y = lat, group = group)) +
geom_polygon(aes(fill = m.price)) +
facet_wrap( ~ year, ncol = 1) +
expand_limits(x = df.merge$long, y = df.merge$lat) +
theme_minimal()
## ---- message = FALSE, warning = FALSE-----------------------------------
# devtools::install_github("hrbrmstr/ggcounty")
library("ggcounty")
data(population) # built-in US population by FIPS code data set
population$brk <- cut(population$count,
breaks=c(0, 100, 1000, 10000, 100000, 1000000, 10000000),
labels=c("0-99", "100-1K", "1K-10K", "10K-100K",
"100K-1M", "1M-10M"),
include.lowest=TRUE) # define appropriate (& nicely labeled) population breaks
us <- ggcounty.us()
gg <- us$g # start the plot with our base map
gg <- gg + geom_map(data=population, map=us$map,
aes(map_id=FIPS, fill=brk),
color="white", size=0.125) # add a new geom with our population (choropleth)
gg <- gg + scale_fill_manual(values=c("#ffffcc", "#c7e9b4", "#7fcdbb",
"#41b6c4", "#2c7fb8", "#253494"),
name="Population")
## ---- echo = FALSE-------------------------------------------------------
# library(devtools)
# install_github("hrbrmstr/ggcounty")
library("ggcounty")
# built-in US population by FIPS code data set
data(population)
# define appropriate (& nicely labeled) population breaks
population$brk <- cut(population$count,
breaks=c(0, 100, 1000, 10000, 100000, 1000000, 10000000),
labels=c("0-99", "100-1K", "1K-10K", "10K-100K",
"100K-1M", "1M-10M"),
include.lowest=TRUE)
# get the US counties map (lower 48)
us <- ggcounty.us()
# start the plot with our base map
gg <- us$g
# add a new geom with our population (choropleth)
gg <- gg + geom_map(data=population, map=us$map,
aes(map_id=FIPS, fill=brk),
color="white", size=0.125)
# define nice colors
gg <- gg + scale_fill_manual(values=c("#ffffcc", "#c7e9b4", "#7fcdbb",
"#41b6c4", "#2c7fb8", "#253494"),
name="Population")
gg
## ---- message = FALSE, warning = FALSE-----------------------------------
df = read_csv("http://wfs-kbhkort.kk.dk/k101/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=k101:baenk&outputFormat=csv&SRSNAME=EPSG:4326")
names(df)
## ---- message = FALSE, warning = FALSE-----------------------------------
library("dplyr")
library("stringr")
df = df %>%
select(wkb_geometry, baenk_tilstand)
# cleaning
df$wkb_geometry = gsub("\\(|\\)", "", df$wkb_geometry)
df$wkb_geometry = str_extract(df$wkb_geometry, "[0-9].+")
x = str_split(df$wkb_geometry, pattern  = " ")
x = do.call(rbind.data.frame, x)
df = bind_cols(df, x)
names(df) = c("wbk_geometry", "baenk_tilstand", "lat", "lon")
df$lon = as.numeric(as.character(df$lon))
df$lat = as.numeric(as.character(df$lat))
## ---- cache = TRUE, message = FALSE, warning = FALSE---------------------
library("ggmap")
qmplot(lat, lon, zoom = 15, data = df,
maptype = "toner-background", color = I("red"))
